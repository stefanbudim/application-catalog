plugins {
    // Apply the application plugin to add support for building a CLI application in Java.
    id 'java'
    id 'application'
    //id 'com.github.johnrengelman.shadow' version '7.1.2'
    //id 'com.github.johnrengelman.shadow' version '9.0.0-SNAPSHOT'
}


// Function to get version from Git tag or provide a default
def getVersionName = { ->
    try {
        // Check if .git directory exists to avoid errors in non-git environments
        if (!file('.git').exists()) {
            return "0.0.1-SNAPSHOT" // Default if not a git repo
        }
        // Execute git describe to get the most recent tag
        def stdout = new ByteArrayOutputStream()
        exec {
            commandLine 'git', 'describe', '--tags', '--abbrev=0'
            standardOutput = stdout
            ignoreExitValue = true // Don't fail if no tags found yet
        }
        def tag = stdout.toString().trim()
        // If git describe fails or returns nothing (e.g., no tags), use a default
        if (tag.isEmpty()) {
             // Optionally, get commit hash for snapshot version
             stdout = new ByteArrayOutputStream()
             exec {
                 commandLine 'git', 'rev-parse', '--short', 'HEAD'
                 standardOutput = stdout
             }
            return "0.0.1-${stdout.toString().trim()}-SNAPSHOT"
        } else {
            return tag
        }
    } catch (Exception e) {
        // Fallback in case of any other error executing git
        println "Could not determine version from Git: ${e.message}"
        return "0.0.1-SNAPSHOT"
    }
}

group = 'org.example'
version =  getVersionName()
project.ext.buildTimestamp = new Date().format('yyyy-MM-dd HH:mm:ss Z') // Store timestamp
def _archiveBaseName= 'application-catalog'
println "Building version: ${version}"


repositories {
    // Use Maven Central for resolving dependencies.
    mavenCentral()
}


dependencies {
    // Use JUnit test framework.
    testImplementation libs.junit

    // This dependency is used by the application.
    implementation libs.guava

    implementation 'org.yaml:snakeyaml:2.3'
    implementation 'org.freemarker:freemarker:2.3.32'
}

// Apply a specific Java toolchain to ease working on different environments.
java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(25)
    }
}

application {
    // Define the main class for the application.
    mainClass = 'org.example.AppCatalogGenerator'
}

// run from src project build dir
tasks.register('generateCatalog', JavaExec) {
    group = 'application'
    description = 'Generate Application-Catalog.html from data.yaml'
    classpath = sourceSets.main.runtimeClasspath
    mainClass.set('org.example.AppCatalogGenerator')
    // --- Set working directory to project root ---
    //By default, JavaExec runs with the project build directory as the working directory. You need to tell it to run with the project root (or wherever data.yaml actually is) as the working directory.
    //workingDir = project.projectDir
    //args("--data", "${project.projectDir}/data.yaml")
    args("--data", "./build/resources/main/data.yaml")
    args("--output", "../data/Application-Catalog.html")
    args("--stages", "development,test,integration,production")
    //args("--view", "../data/custom-view.ftl")

}

// P: dependecies are missing
jar {
    manifest {
        attributes 'Main-Class': application.mainClass
    }
}

//P:
//Shadow plugin relies on some internal Gradle APIs (convention) that were removed or changed in Gradle 9.x. Basically:
//Shadow 7.x works on Gradle 6â€“8.
//Shadow 8.x partially works on Gradle 8.x, but not on Gradle 9.x.
//Gradle 9 removed convention API, so Shadow fails to apply.
/*
shadowJar {
    archiveBaseName.set(_archiveBaseName)
    archiveClassifier.set('')
    archiveVersion.set('1.0.0')
}
*/

// Fat JAR task for Gradle 9.x

// Fat JAR task for Gradle 9.x
tasks.register('fatJar', Jar) {
    archiveBaseName.set(_archiveBaseName)
    archiveClassifier.set('')
    archiveVersion.set( version )
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    // Include compiled classes from main source set
    from(sourceSets.named("main").map { it.output })

    // Include all runtime dependencies
    from({
        configurations.runtimeClasspath.filter { it.name.endsWith("jar") }.collect { zipTree(it) }
    })
    manifest {
        attributes(
            'Main-Class': 'org.example.AppCatalogGenerator',
            'Implementation-Title': 'Application Catalog',
            'Implementation-Version': version,
            'Built-By': System.getProperty('user.name'),
            'Built-Date': project.ext.buildTimestamp,
            'Built-JDK': System.getProperty('java.version')
        )
    }
}

tasks.register('runFatJar', JavaExec) {
    group = 'application'
    description = 'Run the fat JAR generated by fatJar task'
    dependsOn('fatJar')

    mainClass.set('org.example.AppCatalogGenerator')
    classpath = files("app/build/libs/${_archiveBaseName}-${version}.jar")
}
